**方針**
> - 読んでないところ、わからないところは「TODO」残す
> - 質問が来そうなところは、先回りして説明コードを書いてみる
> - 読み方
>   - 各節の末尾に まとめが書いてあるので、そこを読んでいく。
>   - 詳しく知りたい内容だったら、本文を読む。
>   - 上から順に読まない。
> - アウトプット
>   - 知らなかったことをまとめて書き出す。
>   - 不明点（調査項目）
>   - みんなに質問したいこと
>   - 自分で追加調査したいこと


# 第11章 テスト

> `ruby -c` で構文チェック。

vif ではやってた。
内部DSLを使う際に、設定ファイルの構文チェッカーとして使える。
git commit する際のフックとかに入れたらどうなのかなと思っていた。
実際には試してない。前例を調べてみたい。

> 基本的に「コンパイラはプログラマーの友達」

それ、プログラマー違う、キャプテン翼や。

> `ruby -w` で冗長な警告。

RUby 2.7 -> 3.0 の移行期に使った記憶あり。
3.0 で動かなくなる構文を警告してくれる。ALではまだ使ってたかも。


## テスト手法

- TAD (Test After Development)
  手動テスト
  デメ: 実装しやすい方式で実装される。テストしにくい。
- TDD (Test-Driven Development)
  テスト駆動開発。テストファースト
  デメ: テストのためのI/F設計になりがち。
- BDD (Behavir-Driven Development)
  デメ: 仕様を明確に間違いなく記述できる人間などいない。

## それぞれのデメリット

コード例が載っていて、わかりやすかった。
TADでの実装例でも、Rubyならテストできる。他の言語なら無理。

TDDの例では、確かに使いにくい。
こんなI/F設計になってしまうパターンは見たことない。TDD開発プロジェクトを見たことないため？

TDDは、新機能開発の際には最適とは言えない。
バグ改修のときには最適。
正しい仕様が明確で、バグがあることが明確。
テストを書けば再現できる。それをクリアできれば改修完了。
とてもわかりやすい。

新機能開発の際は、正しい仕様が厳密に完全に説明できる人間がいない。
設計書を書いてもらっても、同じこと。動かしてないのだから、完全にはわかっていない。
誰もわかっていない状態で、どうあるべきかを考えながら作っていく。

### テストの複雑性

> 複雑性を低減するために、抽象化

抽象化してしまうのは、複雑性というより、DRYのため？
抽象化する方が複雑性はあがる。

テストコードは、プロダクトコードと違う。
抽象化しない方が良い。
処理フローを一本にし、if分はだめ、ループ処理も asset ではよろしくない。
コピペでベタで書くべき。


### テストのレベル

- ユニットテスト
- モデルテスト
- インテグレーションテスト
- 受け入れテスト

内部仕様のテストを書いてしまって、変更に弱くなる（テストが壊れる）例。
「ホワイトボックス」

> Webシステムで重要なのは「受け入れテスト」

いわゆるブラウザテスト。
手動テスト。
「ブラックボックス」


### カバレッジ100%に意味はない

実際、JUnit 導入したてで、カバレッジ測定ができるようになり、
意味もなくカバレッジ 100%を目指すプロジェクトがあった。

カバレッジ100%でなくとも、コード品質と状況による。
トレードオフ。

コードレビューと手動テスト、デバッガーなどの手法も組み合わせて、
問題ないことがわかればカバレッジ100%未満でも
そのまま納品する。

ただし「テストしていないのはダメ」

#### 種類

- 行カバレッジ
- ブランチカバレッジ
  テスト利用でいう「条件分岐網羅」
- メソッドカバレッジ
  メソッドが呼ばれたかどうか。行カバレッジと本質的に同じ。



