

> 他の人にとっても直感的なものにするには「組み込みクラスを使うこと」

状況がわからないので単純には賛同できない。
「よくわからん独自クラス」をいっぱい使うぐらいなら、標準の Hash を使うべき？

### 戻り値

true / false の章では戻り値について触れられていた。
`select!` などが `nil` を返すことで、`if` 文とくみ合わせできる。
ただし、メソッドチェーンが使えなくなる。

`!` 付きのメソッドは、破壊的メソッド。
メソッドチェーンは使えなくなる、という暗黙的ルールがあるように思う。
（なので使えなくて問題ない）

### キャッシュ

> キャッシュする時に `||=` 使うけど、 `false` や `nil` をキャッシュできない。
> `defined?()` を使えば出来る。
> ハッシュを使う場合は `fetch() { }` が使える。

```rb
cache.fetch(:key) { cache[:key] = some_expression }
```

これは見たことなかった。
冗長なので、あまり美しくない。Rubyぽくない。定石なのかな？アイデアとしては良さそう。
`Rails.cache.fetch do ~~ end` の方がよっぽどいい感じ。

### 整数型

`Float` `BigDecimal` は復習になった。
`Rational` は数学計算用。業務システムでは使わない。今まで１回も使ったことない。

二進小数の誤差は斜め読み。
`BigDecimal` 使いましょう。
ちなみにこれは組み込みクラスではなく標準添付ライブラリ。

### シンボルと文字列の違い

斜め読み。
Ruby言語のパース手順について説明があったのは良かった。
コンパイル時に確定する情報と、動的ディスパッチ。なるほど。

> 「常にシンボルを渡す」で実行性能があがる

それ、動的ディスパッチちゃうやん。

> シンボルの `< > <=>` は文字列比較と同じ効果

なるほど。普段意識してなかった。当たり前と思っていた。
シンボルへの `downcase` `capitalize` なども使える。よくできてるな〜。

**シンボルと文字列の使い分け**
> 識別子が必要ならシンボル、テキストやデータが必要なら文字列

これはいい指標ですね。わかりやすい。
普段暗黙的にそうしているが、明示的に言葉にしてくれた。

シンボルと文字列の相互変換による実行速度の低下について触れられているが、
Railsではそこまで気にしなくても良いと思った。
もっと気にしないといけないことがたくさんあるため。
- 大体問題になるはSQLが重い
- N+1問題
- 無駄なループ
- キャッシュの有効活用

なので、些細な実行性能の差よりも生産性や可読性を重視すべき。

### 配列、ハッシュ、セット

`Set` は昔は `Hash` のキーより遅かったので、使っていなかった。
代わりに `Hash` のキー部分だけを使っていた。
最近は `Set` の方が早くなった。
`Set` もっと使われるべき。

ところで `Hash` ってなんでこの名前にしたんだろう。
そもそもこれは連想配列であり、ハッシュテーブルかどうかは実装依存でいいのに。
ハッシュテーブルはアルゴリズムの名前のはず。なのにデータ構造の名前になりつつある。

### インメモリデータベース

例が直感的でなかった。
オムニバスアルバム？
アルバム内の曲ごとにアーティストが異なる？曲名と捉えた方がわかりやすかった。

クラス設計時の内部のデータ構造を組んでいくときの考え方をウォークスルーしていく感覚だった。
`lookup` がラムダで書かれていて、なぜクラスにしない？

以下のようなデータ構造の方がシンプルで使いやすそう。
```rb
{
  'アルバム名' => [
    '曲名1(アーティスト名)',
    '曲名2(アーティスト名)',
    '曲名3(アーティスト名)',
  ],
  'アルバム２' => [
    '曲名1(アーティスト名)',
    '曲名2(アーティスト名)',
    '曲名3(アーティスト名)',
  ],
}
```

`lookup()` でトラック指定なしのときに、全部列挙して返したいので、内部のデータ構造をどうするかって話。
曲番号が歯抜けになる場合があるのかどうか、書かれていなかった。

そもそも `lookup` の戻り値の型が異なることになるので、別のメソッドにすべき。
`lookup_all` とか。

`Array#&` が登場。Ruby 3.1 では `intercection` という別名が付けられたので、こっちを使う方が理解しやすい。
配列の線形探索よりも 連想配列で検索する方が早いという話。
情報処理の基本。計算量 `O(log n)` ですね。

配列の件数が100以上あるなら、気にした方がいいけど、小さい配列ならあんまり変わらない。
業務アプリでは、そこまで気にしなくてもよいのでは？
競技プログラミングの世界。
`Array.uniq!` して二分探索する方が早かったり、ケースバイケース。

ただし、アルゴリズムを全く理解せずに使うのはダメなので、基本的なデータ構造とアルゴリズムは理解しておべき。


> セットはハッシュよりも遅い

そうなんですよね。Javaの時代から `HashSet` を多用してきた自分としては衝撃的だった。
Ruby は `Hash` の使用頻度があまりにも大きく、`Hash` の最適化とパフォーマンス追求が言語の実行速度に直結するので、
`Set` の内部実装として `Hash` を使うのが最も手軽でパフォーマンスも無難なので、そうなってるのかなと理解。

訳註で Ruby は 組み込みクラスになったと書かれてあった。
Ruby 3.3 の公式リファレンスでは `require 'set'` と書かれたまま。
https://docs.ruby-lang.org/ja/latest/library/set.html
どっちなんだろう。
https://qiita.com/jnchito/items/bdee57b45f12a0d5eeae#set%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%8C%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%9F
によると、`irb` では内部的に `require 'set'` されてるとのこと。知らなかった。

経緯を読んでいると、 `Set` を普及させるために組み込みクラスに移動した？
https://bugs.ruby-lang.org/issues/16989
その際、Set リテラルについて議論されていて、なるほどなと思った。
その際にC言語で書き直すかについても触れられているが、まだ書き直されていない。
`Set` がネイティブコードで書き直されて、`Hash` よりも早く、省メモリになったら出番が増えるだろうに。

#### 自分なりの解釈

一時期は `Set` の代わりに `Hash` で書いていたこともあった。
今は `Set` を積極的に使うようにしている。
- 値のない一意な集合を扱う場面で、`Hash` のキーだけを使って書くより、`Set` を使う方が意味的にわかりやすい。
- `Set` の存在意義。組み込みクラスになった理由はそこにあると思う。
- 将来的に `Set` がネイティブで書き直されたて、`Hash` より早くなるかもしれないし、今から `Set` で書いておいて損はない。

`SortedSet` というのもあり、rbtree というgemがあると、早くなる。
`SortedSet` それ自体が gem に追い出された。

### Struct

> Structは Ruby の組み込みクラスのなかでも不当に評価が低い

同意。確かに使われなさすぎ。
既存コードでも、Struct 登場するところは自分が書いたところ。なんでだろう？
スクリプト言語だし、タイプセーフとか気にしないから、Hashでやっちゃう？
どうせテストコード書くし？インテリセンス効かないし？確かにそうですよね。

`Struct.new` の特殊性についての説明。
確かに。面白いですよね。メタプログラミング。
だから逆にわかりにくいのかな？

`Struct.new` の内部の動きの説明がされていた。
だからどうだ、という結論がないので、ふーんという感じ？

`Struct.new` にブロックを渡して、メソッド定義ができる。
コンストラクタをオーバーライドしている例があった。
こっちの説明の方が重要だと思う。
イディオムや定石として使えるものを多く紹介して欲しいなと思った。

`freeze` すればイミュータブル（不変オブジェクト）に出来る。
これは知らなかった。なるほど、使い所がありそうですが、訳註にあるように、
Ruby 3.2 からは `Data` クラスができたので、そっちを使うべきですね。

### 復習問題

1. Falsy な値として評価される。
    Ruby では、nil, false 以外はすべて真となる。
2. なる。
    Float だと、二進小数の問題があるため、十進小数で表現できる計算ができない。
3. 妥当ではない。
    シンボルは識別子、文字列はデータ、として使い分けるべき。
4. `Hash`。ネイティブコードで書き直されたら `Set` のはず。
    `Set` の中で `Hash` を使っているため。組み込みクラスなのに。
5. `Struct.new` `Class.new` かな。
    難しい問題でした。 `Class.new` でクラス定義できるから、それを `Struct` の節で対比として説明すれば理解が深まったように思う。
    https://stackoverflow.com/questions/9404184/creating-a-class-dynamically

最後に問題があるのは、とてもいいなと思いました。

https://note.com/globis_engineers/n/n6279007a8d75
これ見つけました。
