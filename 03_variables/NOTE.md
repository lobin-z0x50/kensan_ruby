# 第3章 変数を適切に使う

Rubyでも、ローカル変数はスタック。

メソッドを、ブロックとしても使えるようにしておくことで、`filter` や `pertition` に渡せる。
`to_proc` を実装する必要がある。

proc の中で繰り返し `attr_reader` を参照しているのが、実行性能が悪いのでローカル変数にキャッシュしましょうと。
これはちょっと気にしすぎ。`attr_reader` ぐらいならそこまで気にしなくても良い。
毎回DB参照しているとかだったら、キャッシュする効果は大きい。

それよりも最後のコード、`if - else` が４つの分岐になってしまっており、複雑度が上がっている。
実行性能は良いのかもしれないが、可読性が下がってしまっている。
そもそもこんな低レベルレイヤーで実行性能を求めるなら、Ruby ではなく C++ で書くべき。

定数をローカル変数に入れるサンプル。
認知負荷が増大するので、やめようと。
そもそも、クラスを変数に入れているようなメタプログラミング的なアプローチなので、やりたいことと認知負荷の話は全く別。
言ってることがよくわからない。

### 安全ではない最適化

そもそも、些細な実行性能向上を期待して、余計な最適化をしようとしなければ良いのでは？
業務アプリ開発では、逆にこういうコードが負債になる。

### スコープゲート

この単語は初めて聞いた。正式な名称なのか、この本だけの呼び名なのか。その辺もちゃんと書いておいて欲しい。
要は「変数のスコープ」のことですね。

`Class.new` `Module.new` でスコープを作らないようにできる。
ラムダ式と同じように、外の変数が見える、クロージャになる。
`do 〜 end` で書いているので、ブロックである。文法的にも理にかなっている。

`define_method` とクラスローカル変数を組み合わせた隠蔽。
これはいいですね。
JSでいう
```js
(function() {
    ...
  })()
```
みたいなやつ。グローバル汚染対策。

### ローカル変数の命名

「わかりやすさ」と「読みやすさ」。
「変数名の長さを、変数のスコープの広さに比例させる」
これは確かにそうですね。
明示的にそのように説明されたことは少ないように思う。

`i` `k` `v`
`key_list` `value_list` の例示。
わかりやすくてとてもいいと思いました。

## インスタンス変数

即値オブジェクトは、インスタンスの区別がない。全て同じ。だからインスタンス変数を持たせる意味がない。
`nil` をローカル変数に入れる例。わかりやすい。確かにその通り。
で、「インスタンス編をもたせる意味がない」ではなく、実際に持たせることが出来ないのか、実はできるのか、どっちなのか気になる。

また実行性能の話。
`defined?` の例はすでにみてきた。インスタンスにキャッシュを持たせる定石構文



