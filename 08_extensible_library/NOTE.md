# 第8章

> **前回のT**
> 
> - 読み方の工夫は継続。時間を有効に使う。
> - 読んでないところ、わからないところは「TODO」残す
> - 質問が来そうなところは、先回りして説明コードを書いてみる
> 
> **読み方**
>   - 各節の末尾に まとめが書いてあるので、そこを読んでいく。
>   - 詳しく知りたい内容だったら、本文を読む。
>   - 上から順に読まない。
> - アウトプット
>   - 知らなかったことをまとめて書き出す。
> - 不明点（調査項目）
>   - みんなに質問したいこと
>   - 自分で追加調査したいこと

「book インスタンスが呪われている」
特異メソッドの定義を端的に表していて、直感的に理解しやすそう。

設計上、拡張性を意識している/していない
- C# や Java では、public/protectrd, virtual/@override, seal/final
などの予約語を使って拡張可能性（または保護）を宣言する必要があった。
- Rubyでは なにもない。拡張性の宣言をしなくても、拡張可能。->オープンクラス
private メソッドでさえ簡単に呼べる。


そもそも、ちゃんとしたオブジェクト指向。
Userクラス、Bookクラスの責務がしっかりしていて,
そこができる前提になっている。

include, extend の使い分け

```rb
# includeは定義時に使う
class A
  include B
end

# extend は実行時にインスタンスに対して使う
c = Object.new
c.extend C
```
extend は、インスタンス生成後に、「実は C を継承してたことにする」
みたいなことを後付けで出来る。
Rubyならでは。

`prepend` もある。継承関係を後ろにする。

mixでのプラグインシステム
- 結局、`plugin()` でプラグインしたいモジュールに依存してしまっている。
- 真の意味でのプラグインではない。元のアプリを改変せずに、機能追加できるのがプラグイン。
- この書き方だと `plugin()` を書き換えないと、プラグインを変更できない。
- ちゃんとやるなら、プラグインディレクトリを実行時にサーチして、`require_relative` で読み込む。 

クラスレベルのでの変更
- C#/Java では難しい。黒魔術を使えば動的にサブクラスを生成可能。
- そもそも、それを必要としないようなクラス設計にすれば、困りごとは解決できる。
- ブリッジパターン、AbstractFactoryパターン

`after_load` `before_load` フック。
ActiveSupport のコールバック的な感じ。

プラグインシステムでサブクラスを扱う
- DI使おう。

設定可能なプラグイン
- これはとてもいい考え方。

カスタムクラスでの freeze の考慮。
- C++ での const の論争を思い出す。


